#include "Rules.h"

// проверка выигрышной стратегии для компьютера
void bot_checking(char board[], int* choice)
{
	// цикл поиска выигрышной для компьютера комбинации
	for (int i = 0; i<24; i++) 
	{
		int j = 0; 
		// проверка, возможно ли выполнить данную стратегию
		if (board[can_win[i][j]] == board[can_win[i][j + 1]] 
			&& board[can_win[i][j + 1]] != ' '
			&& board[can_win[i][j + 2]] == ' ')
		{
			//выбор стратегии
			*choice = can_win[i][j + 2];
		}
	}
}


// ход компьютера
void bot(char board[], int* choice)
{
	// переменной присваивается значение -1 (т.к. работа идёт с массивом)
	*choice = -1;
	// проверка выигрышной стратегии для компьютера
	bot_checking(board, choice);
	//проверяется условие выбора стратегии, если оно верно - делается выбор
	if (*choice == -1)
	{
		*choice = bot_turn(board, choice); 
	}
}

// выполняет выбор клетки для хода компьютера таким образом, чтобы она не была занята игроком или самим компьютером
int bot_turn(char board[], int* choice) 
{
	// переменная, запоминающая, является ли ход верным
	bool right_choice = 0;
	while (!right_choice)
	{
		// выполняет инициализацию генератора случайных чисел
		srand(time(0));
		// компьютер делает случайный ход в зависимости от стратегии, описанной в функции выше
		*choice = rand() % 9;
		// проверка, нет ли метки "X" или "O" в выбранной ячейке
		if (board[*choice] != 'X' 
		 && board[*choice] != 'O')
		{
			right_choice = 1;
		}
	}
	// возвращение значения выбора
	return *choice; 
}

// проверка на возможность хода (не занята ли клетка)
void check_move(char board[], int* turn, int* choice)
{
	// проверка условий возможности хода
	if ((board[*choice] == ' ')
	 || (board[*choice] == '1'+ *choice) 
	 && (*choice<9))
	{
		// ход первого игрока ("X")
		if (*turn % 2 == 0)  
		{ 
			//на выбранную позицию ставится метка "X"
			board[*choice] = 'X';
			//очистка экрана
			system("cls"); 
		}
		// ход второго игрока ("O") 
		else
		{ 
			//на выбранную позицию ставится метка "X"
			board[*choice] = 'O';
			//очистка экрана
			system("cls");
		}
	}
	else // если ход невозможен (клетка уже занята)
	{
		// очередь не меняется
		*turn -= 1; 
		/* вывод на экран сообщения о том, что ход неверный 
		(занята ячейка или введено некорректное значение)*/
		cout << "Неверный ход!";
	}
}


/* объявляет о ходе каждого из игроков (при игре против компьютера
его ход не объявляется и производится автоматически)*/
void move(char board[], char* variant, int* turn, int* choice)
{
	// смена очереди
	*turn += 1;
	// ход первого игрока ("X")
	if (*turn % 2 == 0)
	{
		// вывод сообщения о том, какой игрок ходит
		cout << " Ходит игрок X:";
		// проверка на введение числа (если введён другой символ - будет сообщение об ошибке)
		while (!(cin >> *choice) || (cin.peek() != '\n')) 
		{
			cin.clear();
			while (cin.get() != '\n');
			
			cout << "Ошибка!" << endl;
		}
		// переменной выбора присваивается значение с -1 (т.к. работа идёт с массивом)
		*choice = *choice - 1;
	}
	// ход второго игрока ("O")
	if (*turn % 2 != 0)
	{
		if (*variant == '1')
		{
			// ход компьютера, если игра идет против него
			bot(board, choice); 
		}
		else
		{
			// вывод сообщения о том, какой игрок ходит
			cout << " Ходит игрок O:";
			// проверка на введение числа (если введён другой символ - будет сообщение об ошибке)
			while (!(cin >> *choice) || (cin.peek() != '\n')) 
			{
				cin.clear();
				while (cin.get() != '\n');
				// вывод на экран сообщения об ошибке
				cout << "Ошибка!" << endl;
			}
			// переменной выбора присваивается значение с -1 (т.к. работа идёт с массивом)
			*choice = *choice - 1;
		}
	}
	// происходит проверка возможности хода
	check_move(board, turn, choice);
}